#include "bootpack.h"

#define PIT_CTRL 0x0043
#define PIT_CNT0 0x0040
#define TIMER_FLAG_ALLOC  1
#define TIMER_FLAG_USING  2

struct TIMERCTL timerctl;

void init_pit(void)
{
int i;
io_out8(PIT_CTRL,0x34);
io_out8(PIT_CNT0,0x9c);
io_out8(PIT_CNT0,0x2e);
timerctl.count =0;
timerctl.next = 0xffffffff;
timerctl.using = 0;

for(i=0;i<MAX_TIMER;i++)
{
timerctl.timers0[i].flag =0; // unused 
}
return;
}

struct TIMER * timer_alloc(void)
{
int i;
for(i=0;i< MAX_TIMER;i++)
{
if(timerctl.timers0[i].flag == 0)
{
	timerctl.timers0[i].flag = TIMER_FLAG_ALLOC;
	return &timerctl.timers0[i];
}
}
return 0;
}

void timer_free(struct TIMER * timer)
{
	timer->flag =0;
}



void inthandler20(int *esp)
{
int i;
struct TIMER *t;
io_out8(PIC0_OCW2,0x60);
timerctl.count++;
if(timerctl.next > timerctl.count)
	return;

t = timerctl.timers[0]; // points to the first element
for(i=0;i< timerctl.using ; i++)
{
if(t->timeout > timerctl.count)
	break;
// timeout
t->flag = TIMER_FLAG_ALLOC;
fifo_put(t->fifo,t->data);
t = t->next;
}
timerctl.using -=i;
timerctl.timers[0] = t;
if(timerctl.using > 0 )
	timerctl.next = timerctl.timers[0]->timeout;
else
	timerctl.next = 0xffffffff;
return;
}


void timer_set(struct TIMER * timer,unsigned int timeout,struct FIFO *fifo,int data)
{
int e;
struct TIMER *s,*t;
timer->timeout = timerctl.count + timeout;  // compare with count
timer->flag = TIMER_FLAG_USING;
timer->fifo = fifo;
timer->data = data;
e = io_load_eflags();
io_cli();
timerctl.using++;

if(timerctl.using == 1) // only one timer is running 
{
timerctl.timers[0] = timer;
timer->next = 0;
timerctl.next = timeout;
io_store_eflags(e);
return;
}

t = timerctl.timers[0];
if(timeout <= t->timeout)
{
timerctl.timers[0] = timer;
timer->next = t;  
timerctl.next = timeout;
io_store_eflags(e);
return;
}

for(;;)
{
	s = t;
	t = t->next;
	if(t == 0)
		break;
	if(timeout <= t->timeout)
	{
	s->next = timer;
	timer->next = t;
	io_store_eflags(e);
	return;
	}
}


s->next = timer;
timer->next = 0;
io_store_eflags(e);
return;
}
